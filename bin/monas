#!/bin/bash
# bin/monas - Claude agent orchestration tool
set -euo pipefail

MONAS_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
COMMAND="${1:-}"
shift || true

usage() {
  echo "Usage: monas <command> [options]"
  echo "Commands:"
  echo "  owner                    Start an interactive Claude session as Owner"
  echo "  leader -- <instruction>  Start Leader and spawn members"
  echo "  status                   Show the latest run status"
  echo "  logs [member_name]       Tail logs for leader or specific member"
  echo "  stream [interval]        Stream task status every N seconds (default: 3)"
}

case "$COMMAND" in
  owner)
    exec claude --append-system-prompt "$(cat "$MONAS_DIR/prompts/owner.md")"
    ;;
  leader)
    if [ "${1:-}" = "--" ]; then
      shift
      INSTRUCTION="$*"
      bash "$MONAS_DIR/scripts/run-leader.sh" "$MONAS_DIR" "$INSTRUCTION"
    else
      usage
      exit 1
    fi
    ;;
  status)
    WORKSPACE="$(pwd)/.monas/latest"
    if [ ! -L "$WORKSPACE" ]; then
      echo "No active workspace. Run 'monas leader -- ...' first."
      exit 1
    fi
    # shellcheck source=scripts/json_helpers.sh
    source "$MONAS_DIR/scripts/json_helpers.sh"
    echo "=== Run: $(readlink "$WORKSPACE" | xargs basename) ==="
    if ! err=$(verify_json_syntax "$WORKSPACE/tasks.json"); then
      echo "ERROR: tasks.json is not valid JSON. Phase 1 may have failed."
      echo "Run 'monas logs' to see the leader log for details."
      exit 1
    fi

    # タスクごとのリッチ表示
    while IFS= read -r TASK_NAME; do
      STATUS=$(jq -r --arg t "$TASK_NAME" '.[$t].status' "$WORKSPACE/tasks.json")
      FINAL_REPORT=$(jq -r --arg t "$TASK_NAME" '.[$t].final_report // ""' "$WORKSPACE/tasks.json")
      LOG_FILE="$WORKSPACE/logs/member-${TASK_NAME}.log"

      # ステータスアイコン
      case "$STATUS" in
        in_progress) ICON="⚡" ;;
        done)        ICON="✓" ;;
        stuck)       ICON="⚠" ;;
        error)       ICON="✗" ;;
        *)           ICON="?" ;;
      esac

      # イテレーション数（ログが存在する場合のみ）
      ITER_LABEL=""
      if [ -f "$LOG_FILE" ]; then
        LAST_ITER=$(grep -oE 'Iteration [0-9]+/[0-9]+' "$LOG_FILE" 2>/dev/null | tail -1 | grep -oE '[0-9]+/[0-9]+' 2>/dev/null || true)
        [ -n "$LAST_ITER" ] && ITER_LABEL="iter $LAST_ITER"
      fi

      # ヘッダー行: [アイコン タスク名] ステータス  iter X/15
      printf "[%s %s] %s%s\n" "$ICON" "$TASK_NAME" "$STATUS" "${ITER_LABEL:+  $ITER_LABEL}"

      # in_progress / stuck: 経過時間と最後のアクション
      if [ "$STATUS" = "in_progress" ] || [ "$STATUS" = "stuck" ]; then
        if [ -f "$LOG_FILE" ]; then
          # 最終タイムスタンプから経過時間を計算
          LAST_TS=$(grep -oE '^\[[0-9]{2}:[0-9]{2}:[0-9]{2}\]' "$LOG_FILE" 2>/dev/null | tail -1 | tr -d '[]' || true)
          if [ -n "$LAST_TS" ]; then
            NOW_SEC=$(date '+%s')
            LAST_SEC=$(date -d "$LAST_TS" '+%s' 2>/dev/null || true)
            if [ -n "$LAST_SEC" ]; then
              ELAPSED=$(( NOW_SEC - LAST_SEC ))
              # 日付をまたいだ場合の補正
              [ "$ELAPSED" -lt 0 ] && ELAPSED=$(( ELAPSED + 86400 ))
              echo "  Last activity: ${ELAPSED} sec ago"
            fi
          fi
          # 定型句を除いた最後の意味ある行
          LAST_ACTION=$(grep -vE '(Output received\.|Not done yet\.)' "$LOG_FILE" 2>/dev/null | tail -1 | sed 's/^\[[0-9:]*\] \[member-[^]]*\] //' || true)
          if [ -z "$LAST_ACTION" ]; then
            LAST_ACTION=$(tail -1 "$LOG_FILE" 2>/dev/null | sed 's/^\[[0-9:]*\] \[member-[^]]*\] //' || true)
          fi
          [ -n "$LAST_ACTION" ] && echo "  → \"$LAST_ACTION\""
        fi
      # done: final_report を表示
      elif [ "$STATUS" = "done" ] && [ -n "$FINAL_REPORT" ]; then
        echo "  → \"$FINAL_REPORT\""
      # error: ログ末尾の行を表示
      elif [ "$STATUS" = "error" ] && [ -f "$LOG_FILE" ]; then
        LAST_ACTION=$(tail -1 "$LOG_FILE" 2>/dev/null | sed 's/^\[[0-9:]*\] \[member-[^]]*\] //' || true)
        [ -n "$LAST_ACTION" ] && echo "  → \"$LAST_ACTION\""
      fi

      echo ""
    done < <(jq -r 'to_entries[] | select(.key != "_thought") | .key' "$WORKSPACE/tasks.json")

    # 全タスク完了かつサマリー未生成の場合、遅延生成（冪等）
    # _thoughtフィールドはタスクではないため除外する
    ALL_DONE=$(jq '[to_entries[] | select(.key != "_thought") | .value.status] | all(. == "done" or . == "error" or . == "stuck")' "$WORKSPACE/tasks.json")

    STUCK_TASKS=$(jq -r '[to_entries[] | select(.key != "_thought" and .value.status == "stuck") | .key] | join(", ")' "$WORKSPACE/tasks.json")
    if [ -n "$STUCK_TASKS" ]; then
      echo "WARN: The following tasks are stuck: $STUCK_TASKS"
    fi
    SUMMARY_FILE="$WORKSPACE/summary.txt"
    SUMMARY_LOCK="$WORKSPACE/summary.lock"
    if [ "$ALL_DONE" = "true" ] && [ ! -f "$SUMMARY_FILE" ] && [ ! -f "$SUMMARY_LOCK" ]; then
      touch "$SUMMARY_LOCK"
      echo ""
      echo "All tasks complete. Generating summary in background..."
      (claude -p "全タスクが完了しました。tasks.jsonの内容を基に、達成内容を簡潔にまとめてください。" \
        --append-system-prompt "$(cat "$MONAS_DIR/prompts/leader-summary.md")" \
        --allowedTools "Read" < "$WORKSPACE/tasks.json" > "$SUMMARY_FILE" \
        && rm -f "$SUMMARY_LOCK") &
    elif [ -f "$SUMMARY_LOCK" ]; then
      echo ""
      echo "=== Summary ==="
      echo "(generating...)"
    elif [ -f "$SUMMARY_FILE" ]; then
      echo ""
      echo "=== Summary ==="
      cat "$SUMMARY_FILE"
    fi
    ;;
  stream)
    INTERVAL=${1:-3}
    WORKSPACE="$(pwd)/.monas/latest"
    trap 'exit 0' INT
    while true; do
      if [ ! -L "$WORKSPACE" ]; then
        echo "waiting for run..."
      else
        TASKS_JSON="$WORKSPACE/tasks.json"
        if [ -f "$TASKS_JSON" ]; then
          echo "time: $(date '+%H:%M:%S')"
          jq -r 'to_entries[] | select(.key != "_thought") | "  * " + .key + ": " + .value.status' "$TASKS_JSON"
          echo "---"
        fi
      fi
      sleep "$INTERVAL"
    done
    ;;
  logs)
    WORKSPACE="$(pwd)/.monas/latest"
    NAME="${1:-}"
    if [ -n "$NAME" ]; then
      LOG_FILE="$WORKSPACE/logs/member-${NAME}.log"
      if [ ! -f "$LOG_FILE" ]; then
        echo "Log file not found: $LOG_FILE"
        if grep -q "FATAL" "$WORKSPACE/logs/leader.log" 2>/dev/null; then
          echo "Phase 1 failed. Members were not started. Check 'monas logs' for details."
        else
          echo "Member '$NAME' may not have been started yet."
        fi
        exit 1
      fi
      tail -f "$LOG_FILE"
    else
      tail -f "$WORKSPACE/logs/leader.log"
    fi
    ;;
  *)
    usage
    exit 1
    ;;
esac
